# 二.解构赋值

### 1.数组

如果左边没有内容，则代表跳过这个值

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
console.log(foo,bar,baz);//1 2 3

let [ ,  second] = ["1", "2", "3"];
console.log(second);//2

let [ , , third] = ["1", "2", "3"];
console.log(third);//3

let [x, , y] = [1, 2, 3];
console.log(x,y);//1 3

let [head, ...tail] = [1, 2, 3, 4];
console.log(head,tail);//1 [2,3,4]
```

如果右边没有对应的值，则为undefined或空

```js
let [foo1] = [];
console.log(foo1);//undefined

let [bar2, foo2] = [1];
console.log(bar2,foo2);//1 undefined

let [x1, y1, ...z1] = ['a'];
console.log(x1,y1,z1);//a undefined []
```

如果左边没有对应的值，也没有写逗号(像情况1那样)

```js
let [x2, y2] = [1, 2, 3];
console.log(x2,y2);//1 2
```

如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```js
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。例如写一个Generator 函数。

解构赋值可以指定默认值，不指定默认值，y就是undefined

```js
let [x, y = 'b'] = ['a']; // x='a', y='b' 
```

注意，当一个数组成员 === undefined，默认值才会生效。而null !== undefined

```js
let [x = 1] = [null];
x // null
```

### 2.对象

数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

取不到值，则是undefined

```js
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined

let {foo} = {bar: 'baz'};
foo // undefined
```

如果变量名与属性名不一致，必须写成下面这样。意思是接受first的值，并命名为f

```
let { first: f, last: l } = { first: 'hello', last: 'world' };//相当
console.log(f,l);//hello world
```

实际上，对象的解构赋值是下面形式的简写

```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```

























